<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue | 犬夜叉的博客</title><meta name="keywords" content="vue"><meta name="author" content="Max"><meta name="copyright" content="Max"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1  VUE 的底层原理？    Vue 是一套构建用户界面的 Model-View-ViewModel(MVVM)渐进式框架。     Vue 只关注视图层， 采用自底向上增量开发的设计。     Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。  MVC:    m：model 模型，数据层     v：View 用户界面，视图层     c：controler">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue">
<meta property="og:url" content="http://example.com/2021/06/15/Vue/index.html">
<meta property="og:site_name" content="犬夜叉的博客">
<meta property="og:description" content="1  VUE 的底层原理？    Vue 是一套构建用户界面的 Model-View-ViewModel(MVVM)渐进式框架。     Vue 只关注视图层， 采用自底向上增量开发的设计。     Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。  MVC:    m：model 模型，数据层     v：View 用户界面，视图层     c：controler">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/back2.jpg">
<meta property="article:published_time" content="2021-06-14T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-02T06:31:27.495Z">
<meta property="article:author" content="Max">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/back2.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2021/06/15/Vue/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-02 14:31:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Web前端</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Vue"><i class="fa-fw fas fa-heart"></i><span> Vue</span></a></li><li><a class="site-page child" href="/categories/React"><i class="fa-fw fas fa-heart"></i><span> React</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/tx.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">犬夜叉的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Web前端</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Vue"><i class="fa-fw fas fa-heart"></i><span> Vue</span></a></li><li><a class="site-page child" href="/categories/React"><i class="fa-fw fas fa-heart"></i><span> React</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-14T16:00:00.000Z" title="发表于 2021-06-15 00:00:00">2021-06-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-02T06:31:27.495Z" title="更新于 2021-07-02 14:31:27">2021-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Vue/">Vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="VUE-的底层原理？"><a href="#VUE-的底层原理？" class="headerlink" title="VUE 的底层原理？"></a>VUE 的底层原理？</h2><pre><code>    Vue 是一套构建用户界面的 Model-View-ViewModel(MVVM)渐进式框架。
    Vue 只关注视图层， 采用自底向上增量开发的设计。
    Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。
</code></pre>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC:"></a>MVC:</h2><pre><code>    m：model 模型，数据层
    v：View 用户界面，视图层
    c：controler 控制器，大量的逻辑都放在controller中
</code></pre>
<h2 id="MVVM：模式，思想，vue-框架的思想符合-mvvm-模式"><a href="#MVVM：模式，思想，vue-框架的思想符合-mvvm-模式" class="headerlink" title="MVVM：模式，思想，vue 框架的思想符合 mvvm 模式"></a>MVVM：模式，思想，vue 框架的思想符合 mvvm 模式</h2><pre><code>    m：Model 模型，数据层
    V：View 用户界面，视图层
    VM：实例化的vue对象
</code></pre>
<h2 id="vue-js-优点："><a href="#vue-js-优点：" class="headerlink" title="vue.js 优点："></a>vue.js 优点：</h2><pre><code>   1.操作数据，不操作DOM，节省性能。
   2.遵循MVVM模式
   3.实现单页面应用
</code></pre>
<h2 id="指令：以-v-开头的特殊属性，主要用来操作-DOM"><a href="#指令：以-v-开头的特殊属性，主要用来操作-DOM" class="headerlink" title="指令：以 v-开头的特殊属性，主要用来操作 DOM"></a>指令：以 v-开头的特殊属性，主要用来操作 DOM</h2><pre><code>     &lt;1&gt;.v-text: v-text=&quot;值&quot;；值需要在数据中声明，作用同&#123;&#123;&#125;&#125;类似语法
         <2>.v-html：v-html="值"；值需要在数据中声明，可以解析DOM元素
         重点v-text与v-html区别：
         v-text只能解析文本，不可以解析html元素。
         v-html可以解析文本，也可以解析html元素。
         <3>.v-show:v-show="表达式"根据表达式的真假值控制元素的显示与隐藏;
         v-show="false"会给元素添加一个display：none的属性
         <4>.v-if:v-if="表达式"根据表达式的真假值控制元素是否存在
         v-if="false"时DOM元素不存在
         重点v-if=""与 v-show=""区别：
          v-show=" "控制元素display：none样式。
          v-if=" "控制元素的删除与添加。（浪费性能）
          频繁切换使用v-show
         <5>.v-else与v-else-if
          v-else：不能单独使用，必须跟在v-if或v-else-if后面(没有表达式)
          v-else-if：不能单独使用，必须放在v-if或v-else-if后面
          v-else-if相当于js  if()&#123;&#125; elseif()&#123;&#125; else&#123;&#125;
         <6>.v-for:v-for="(item,key,index) in obj"用来遍历数组或对象
           item:数组每一项。
           key:键
           index:索引，下标。
          <7>.v-on:绑定事件
           v-on：事件名称不加on="函数名"
           简写@事件名称="函数名"（通常用）
           函数名（参1，参2.。。。）
        修饰符：v-on:click   写在事件名称后面用 .  表示
        事件修饰符
            取消默认
            v-on:click.prevent
            @click.prevent
            取消冒泡
            v-on:click.stop
            @click.stop
        键盘修饰符
            .13 回车键-----键码
            .Esc  Esc
            .enter 回车键--键名
        事件详情  传入@event
           <8>. v-model：给表单元素绑定的指令，不能绑定普通元素，表单元素会忽略value属性，
           把vue实力上的数据作为数据作为数据的初始来源.选中单选按钮：data&#123;aa:"man"&#125;。
           属性名为单选按钮的name，值为value值
           <9>.v-bind：给元素或者组件动态绑定一个或多个属性                语法：v-bind:属性名=值
                简写：:属性名=值
                v-bind:class
                    v-bind:class="类名"。绑定类名
                    v-bind:class="&#123;red:isRed&#125;"。red为key，isRed是布尔值，true为绑定，false为不绑定
                    v-bind:class="[ ]"。绑定数组，数组中每一项都是类名，需要在data中初始化
                    []和&#123;&#125;可混合使用
                v-bind:style动态绑定样式
                    v-bind:style="&#123;width:100px&#125;"
                v-bind="&#123;id:'aaa','attr':'occ'&#125;"自定义属性
           <10>.v-once：直接写，没有值，更新一次
           <11>.v-pre：浏览器不会对其进行编译

## vue 中的计算属性

            计算属性：computed
            属性名：函数名
            属性值：函数的返回值
            依赖于普通属性(data中的数据)，计算属性也会被挂载到当前实例上，也可以使用&#123;&#123;&#125;&#125;
</code></pre>
<h2 id="函数和计算属性的区别"><a href="#函数和计算属性的区别" class="headerlink" title="函数和计算属性的区别"></a>函数和计算属性的区别</h2><pre><code>    用函数去实现每次得到返回结果都会执行函数
    计算属性只会执行一次，然后把结果存在缓存中，以后使用会从缓存中直接获取，不再执行逻辑提高性能
</code></pre>
<h2 id="vue-中的监听属性"><a href="#vue-中的监听属性" class="headerlink" title="vue 中的监听属性"></a>vue 中的监听属性</h2><pre><code>    watch:&#123;&#125;
    监听的数据写成函数，新值与旧值作为函数的参数
    vue在运行的时候，对于非基本数据类型只会监听引用，添加deep:true，
    会给每一层数据绑定监听器，如果有一个值变化都会做出相应
    调用引用类型的写法


    watch:&#123;
&quot;        obj.a.b&quot;:&#123;
            //处理函数handler
            headler:function(newVal,oldVal)&#123;&#125;,
            deep:true//深度监听
        &#125;
    &#125;
</code></pre>
<h2 id="vue-挂在元素的方法和调用方法"><a href="#vue-挂在元素的方法和调用方法" class="headerlink" title="vue 挂在元素的方法和调用方法"></a>vue 挂在元素的方法和调用方法</h2><pre><code>    挂载元素的方法：el:&quot;&quot;
    调用实例的方法$mount(&quot;#app&quot;)
</code></pre>
<h2 id="生命周期钩子：vue-实例从创建，运行到销毁伴随着一些事件，这些事件叫生命周期钩子，也叫做生命周期函数八个生命周期钩子"><a href="#生命周期钩子：vue-实例从创建，运行到销毁伴随着一些事件，这些事件叫生命周期钩子，也叫做生命周期函数八个生命周期钩子" class="headerlink" title="生命周期钩子：vue 实例从创建，运行到销毁伴随着一些事件，这些事件叫生命周期钩子，也叫做生命周期函数八个生命周期钩子"></a>生命周期钩子：vue 实例从创建，运行到销毁伴随着一些事件，这些事件叫生命周期钩子，也叫做生命周期函数八个生命周期钩子</h2><pre><code>    beforeCreate：在实例创建之前运行，el还没有挂载到DOM，实例上的数据方法还没有初始化
    created：实例创建完成，数据和方法已经被初始化，vue实例还没有挂载到元素上

    beforeMount：实例挂载到dom之前执行的函数，此时的dom是虚拟的还不能使用
    mounted：实例挂载到dom之前执行的函数，dom已经渲染完成，可以对dom进行操作

    beforeUpdate：数据更新之前执行的函数
    updated：数据更新完成执行的函数

    beforeDestroy：实例销毁前执行的函数
    destroyed：销毁成功以后执行的函数
</code></pre>
<h2 id="vue-router-有哪几种导航钩子"><a href="#vue-router-有哪几种导航钩子" class="headerlink" title="vue-router 有哪几种导航钩子?"></a>vue-router 有哪几种导航钩子?</h2><pre><code>    1、全局守卫：router.beforeEach
    使用 router.beforeEach 注册一个全局前置守卫：

    constrouter=newVueRouter(&#123;...&#125;)  router.beforeEach((to,from, next) =&gt;&#123;// ...&#125;)

    当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，
    此时导航在所有守卫 resolve 完之前一直处于等待中。

    每个守卫方法接收三个参数：

    to: Route: 即将要进入的目标 路由对象

    from: Route: 当前导航正要离开的路由

    next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。

    next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed(确认的)。

    next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，
    那么 URL 地址会重置到 from 路由对应的地址。

    next(&#39;/&#39;) 或者 next(&#123; path: &#39;/&#39; &#125;): 跳转到一个不同的地址。当前的导航被中断，
    然后进行一个新的导航。你可以向 next 传递任意位置对象，
    且允许设置诸如 replace: true、name: &#39;home&#39; 之类的选项以及任何用在
    router-link 的 to prop 或 router.push 中的选项。

    next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，
    则导航会被终止且该错误会被传递给 router.onError()注册过的回调。

    确保要调用 next 方法，否则钩子就不会被 resolved。

    2、全局解析守卫：router.beforeResolve

    你可以用  router.beforeResolve  注册一个全局守卫。这和  router.beforeEach  类似，
    区别是：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

    3、全局后置钩子：router.afterEach

    你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：

    router.afterEach((to,from) =&gt;&#123;// ...&#125;)

    4、路由独享的守卫：beforeEnter

    constrouter=newVueRouter(&#123;routes:[&#123;path:&#39;/foo&#39;,component:
     Foo,beforeEnter:(to,from, next) =&gt;&#123;// ...&#125;&#125;]&#125;)

    这些守卫与全局前置守卫的方法参数是一样的。

    5、组件内的守卫：beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave

    const Foo=&#123; template: `...`,

    beforeRouteEnter(to, from,next)&#123;

    //在渲染该组件的对应路由被 confirm 前调用

    //不！能！获取组件实例 `this`//因为当守卫执行前，组件实例还没被创建

    &#125;,

    //不过，你可以通过传一个回调给 next 来访问组件实例。

    //在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。

    beforeRouteEnter(to, from,next)&#123;next(vm=&gt;&#123;//通过 `vm` 访问组件实例&#125;)&#125;,

    beforeRouteUpdate(to, from,next)&#123;

    //在当前路由改变，但是该组件被复用时调用//举例来说，
    //对于一个带有动态参数的路径/foo/:id，在/foo/1 和/foo/2 之间跳转的时候，

    //由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。

    //可以访问组件实例 `this`&#125;,

    beforeRouteLeave(to, from,next)&#123;

    //导航离开该组件的对应路由时调用

    //可以访问组件实例 `this`&#125;&#125;

    注意：beforeRouteEnter 是支持给 next 传递回调的唯一守卫。
    对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，
    因为没有必要了:

    beforeRouteUpdate(to,from, next)&#123;// just use `this`this.name= to.params.name

    next()&#125;

    离开守卫 beforeRouteLeave：通常用来禁止用户在还未保存修改前突然离开。该导航可以通过
    next(false)来取消：

    beforeRouteLeave(to, from,next)&#123;

    constanswer= window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)

    if(answer)&#123;next()&#125;else&#123;next(false)&#125;&#125;
</code></pre>
<h2 id="自定义指令："><a href="#自定义指令：" class="headerlink" title="自定义指令："></a>自定义指令：</h2><pre><code>    全局定义
       Vue.directive(&quot;名字&quot;,&#123;关于指令的钩子和逻辑&#125;)
            钩子：
            bind()&#123;&#125;再绑定元素初始渲染时执行
            inserted()&#123;&#125;在dom元素插入到页面时执行
            update()&#123;&#125;在更新时候执行的函数
            钩子的参数：
                el：绑定的dom元素
    局部定义
        在配置对象中写directive
        directive:&#123;
            &quot;指令名&quot;:&#123;
                bind()&#123;&#125;
            &#125;
        &#125;
    名字定义是不加v-，使用时加v-
</code></pre>
<h2 id="组件的概念"><a href="#组件的概念" class="headerlink" title="组件的概念"></a>组件的概念</h2><pre><code>    1.什么是组件：是页面中可复用的局部功能界面
    2.组件化开发的好处：协同开发；可以复用；便于维护
    3.组件的组成部分：html结构；css样式；数据；逻辑
    4.创建组件
        a.全局注册 Vue.component(&quot;组件名&quot;,&#123;关于组建的配置&#125;)
        b.局部注册，在components配置项里面写
           component:&#123;
                &quot;组件名&quot;:&#123;
                    template:``,
                &#125;
            &#125;
    5.使用组件
        把组件名称当作一个自定义的元素放在想放的位置
    6.关于组件中data的问题
        组建的data必须是一个函数，每一个组件都有自己可以维护的数据，
        当修改一个组件的数据，其他组件的数据不会被修改
    7.组件的this指向的是当前组件，在组件上声明的方法和属性都挂载到当前组件上
</code></pre>
<h2 id="双向数据绑定原理："><a href="#双向数据绑定原理：" class="headerlink" title="双向数据绑定原理："></a>双向数据绑定原理：</h2><pre><code>    拦截对象的属性，把每个属性使用object.defineProperty转成setter和getter的形式，
    当属性值变化时执行setter，通知vue把数据重新渲染到页面
</code></pre>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><pre><code>    1.父组件使用v-bind动态绑定数据
    绑定语法 v-bind:属性名=值(要传递给子组件的数据)
    子组件使用props接收父组件传递过来的数据
        props两种写法：
            props上的数据直接挂载到当前组件上
        1.props:[&#39;value&#39;]。value时父组件传递过来的数据
        2.props:&#123;
         key:&#123;
                    type:String,定义接收的数据类型，限制一种数据类型，type:[String,Number]
                    default:value,定义默认值，如果父级没有传递过来数据就是用默认值。
                    如果默认值不是基本数据类型要写成函数返回的形式    default()&#123;return&#123;...&#125;&#125;
                    required:true必须传，false不必要传
                &#125;
            &#125;

    2.子组件向父组件通信
      方法：子组件使用$emit()向上广播事件
     $emit(&quot;自定义事件名称(必填),value(可选)&quot;)
           父组件监听自定义事件，使用v-on:自定义事件名=新的事件名
    在事件属性中定义新事件名，参数为传递过来的值

     3.$attrs
     $attrs：批量向下传递数据，每一个组件都有一个$attrs路由属性，
     用来描述该组件身上的所有属性集合的对象
           继续向下传递用v-bind=&quot;$attrs&quot;
         &#123;&#123;$attrs&#125;&#125;
    4.$listeners
       批量向下传递方法$listeners.click();
      是组件上的属性，用来保存组件身上的方法。继续向下传递使用v-on=&quot;$listeners&quot;
    5.Provide和Inject
        依赖注入和强制注入，扩展更深层的数据传递，在任何后代组件中都可以使用数据
       优点：跨组件获取数据
       使用provide对象发送数据。inject数组接收数据。父组件只需发送一次数据，
       所有子组件都可接收。称为组件上的属性
    6.ref的使用
       string类型，用来给元素或者子组件注册引用信息，引用信息会注册在父组件的$refs对象上
       $refs：类型是object对象，持有已注册过ref的所有子组件
       如果在普通的dom元素上使用，那么引用的注册信息指向dom元素
       如果在组件上使用，引用指向的是组件实例对象，那么可以获取到组件上的属性或者方法
    7.EventBus
       原理：创建一个vue实例，调用实例上的方法
       this.$bus.$emit(&quot;自定义事件名称&quot;,值)发送
       this.$bus.$on(&quot;自定义事件名称&quot;,function(值)&#123;
           函数的参数是发送时候发送的值
       &#125;)接收
       能实现各个组件之间的通信(父子，兄弟，跨组件)
       实现方法：在main.js中创建全新的vue实例
           Vue.prototype.$bus = new Vue()
    8.$parent $children属性
     $parent当前组件的直接父组件
      $children组件的所有直接子组件(如果没有子组件返回一个空数组)，以数组的形式展示
     可以嵌套多层

    插槽
    &lt;slot&gt;&lt;/slot&gt;，当有多个时，
</code></pre>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><pre><code>    页面与页面之间的切换，实现单页面应用开发SPA:Single Page Application
    路由是vue的一个插件
    路由配置
    创建router.js文件，在router.js文件内写配置信息


    1.引入vue
        import Vue from &#39;vue&#39;
    2.引入路由插件，要先安装路由插件，npm install vue-routery
        import Router from &#39;vue-router&#39;
    3.引入组件
        import About from &#39;./views/About&#39;
        import Home from &#39;./views/Home&#39;
        import ChildOne from &#39;./views/ChildOne&#39;
    3.声明使用路由
     Vue.use(Router)
    4.创建路由实例并导出路由
     export default new Router(&#123;
         5.配置路由星系，使用routes选项
            routes:[
                &#123;
                    //指定路由地址
                    path:&quot;/About&quot;,
                    //给路由定义名称
                    name:&quot;About&quot;,
                    //指定路由匹配的组件
                    redirect:&quot;/Home&quot;,
                    //通过children配置子路由
                    children:[
                        &#123;
                            path:&quot;/childone&quot;,
                            component:ChildOne,
                            name:&quot;childone&quot;
                        &#125;,
                        &#123;
                            path:&quot;/childtwo&quot;,
                            component:ChildOne,
                            name:&quot;childtwo&quot;
                        &#125;
                    ]
                &#125;,
                &#123;
                    path:&quot;/Home&quot;,
                    component:Home
                &#125;
            ]
      &#125;)


    在main.js文件里引入router.js文件
        import router from &#39;./router&#39;
        new Vue(&#123;
        router
        &#125;)
    在App.vue文件中插入标签，声明式


    &lt;router-link to=&quot;/About&quot;&gt;&lt;/router-link&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
        router-link组件指定导航，to属性指定导航地址，对应路由的path值
        路由出口组件用来显示对应路由&lt;router-view&gt;
</code></pre>
<h2 id="通过路由跳转的三种方式"><a href="#通过路由跳转的三种方式" class="headerlink" title="通过路由跳转的三种方式"></a>通过路由跳转的三种方式</h2><pre><code>    一.router-link

    1. 不带参数

    &lt;router-link :to=&quot;&#123;name:&#39;home&#39;&#125;&quot;&gt;
    &lt;router-link :to=&quot;&#123;path:&#39;/home&#39;&#125;&quot;&gt; //name,path都行, 建议用name
    // 注意：router-link中链接如果是&#39;/&#39;开始就是从根路由开始，如果开始不带&#39;/&#39;，
    则从当前路由开始。

    2.带参数

    &lt;router-link :to=&quot;&#123;name:&#39;home&#39;, params: &#123;id:1&#125;&#125;&quot;&gt;

    // params传参数 (类似post)
    // 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot;
    // 不配置path ,第一次可请求,刷新页面id会消失
    // 配置path,刷新页面id会保留

    // html 取参  $route.params.id
    // script 取参  this.$route.params.id

    &lt;router-link :to=&quot;&#123;name:&#39;home&#39;, query: &#123;id:1&#125;&#125;&quot;&gt;

    // query传参数 (类似get,url后面会显示参数)
    // 路由可不配置

    // html 取参  $route.query.id
    // script 取参  this.$route.query.id
    二.this.$router.push() (函数里面调用)

    1.  不带参数

    this.$router.push(&#39;/home&#39;)
    this.$router.push(&#123;name:&#39;home&#39;&#125;)
    this.$router.push(&#123;path:&#39;/home&#39;&#125;)


    2. query传参

      this.$router.push(&#123;name:&#39;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)
      this.$router.push(&#123;path:&#39;/home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)

    // html 取参  $route.query.id
    // script 取参  this.$route.query.id


    3. params传参

     this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;)  // 只能用 name


    // 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; ,
    // 不配置path ,第一次可请求,刷新页面id会消失
    // 配置path,刷新页面id会保留


    // html 取参  $route.params.id
    // script 取参  this.$route.params.id

    4. query和params区
       query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传,
       密码之类还是用params刷新页面id还在
       params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失
    三. this.$router.replace() (用法同上,push)

    四. this.$router.go(n)

    this.$router.go(n)
      //向前或者向后跳转n个页面，n可为正整数或负整数1
    ps : 区别
    this.$router.push 跳转到指定url路径，并想history栈中添加一个记录，
    点击后退会返回到上一个页面 1this.$router.replace 跳转到指定url
    路径，但是history栈中不会有记录，点击返回会跳转到上上个页面
    (就是直接替换了当前页面)1this.$router.go(n) 向前或者向后跳转n个页面，
    n      可为正整数或负整数
</code></pre>
<h2 id="路由的优缺点"><a href="#路由的优缺点" class="headerlink" title="路由的优缺点"></a>路由的优缺点</h2><pre><code>    优点：
</code></pre>
<p>用户体验好，不需要每次都从服务器全部获取;根据不同的 url 显示不同的页面，快速展现给用户。</p>
<pre><code>    缺点：

    1.不利于 SEO
    2.使用浏览器的前进，后退键的时候会重新发送请求，没有合理利用缓存
    3.单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置
</code></pre>
<h2 id="vue-router-路由怎么获取传过来的值"><a href="#vue-router-路由怎么获取传过来的值" class="headerlink" title="vue-router 路由怎么获取传过来的值"></a>vue-router 路由怎么获取传过来的值</h2><pre><code>    可以通过query ,param两种方式

    区别: query通过url传参，刷新页面还在    params刷新页面不在了
</code></pre>
<h2 id="route和-router-的区别？"><a href="#route和-router-的区别？" class="headerlink" title="$route和$router 的区别？"></a>$route和$router 的区别？</h2><pre><code>    $route
    route是路由信息对象，里面主要包含路由的一些基本信息，
    包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom
    $route.path
    字符串，等于当前路由对象的路径，会被解析为绝对路径，如 &quot;/home/news&quot; 。
    $route.params
    对象，包含路由中的动态片段和全匹配片段的键值对
    $route.query
    对象，包含路由中查询参数的键值对。例如，对于 /home/news/detail/01?favorite=yes ，
    会得到$route.query.favorite == &#39;yes&#39; 。
    $route.router
    路由规则所属的路由器（以及其所属的组件）。
    $route.matched
    数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。
    $route.name
    当前路径的名字，如果没有使用具名路径，则名字为空。


    $router
    router是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等.例如：
    $router.push(&#123;path:&#39;home&#39;&#125;);本质是向history栈中添加一个路由，
    在我们看来是 切换路由，但本质是在添加一个history记录
    方法：
    $router.replace(&#123;path:&#39;home&#39;&#125;);//替换路由，没有历史记录
</code></pre>
<h2 id="vue-中-this-router-push-路由传值和获取的两种常见方法"><a href="#vue-中-this-router-push-路由传值和获取的两种常见方法" class="headerlink" title="vue 中 this.$router.push()路由传值和获取的两种常见方法"></a>vue 中 this.$router.push()路由传值和获取的两种常见方法</h2><pre><code>    一、路由传值   this.$router.push()
    （1） 想要导航到不同的URL，使用router.push()方法，这个方法会向history栈添加一个新纪录，
    所以，当用户点击浏览器后退按钮时，会回到之前的URL

    （2）当点击 &lt;router-link&gt; 时，这个方法会在内部调用，即点击 &lt;router-link :to=&quot;...&quot;&gt;
    等同于调用 router.push(...)

    a) 声明式：&lt;router-link :to=&quot;...&quot;&gt;

    b) 编程式：router.push(...)

    c) 该方法的参数可以是一个字符串路径，或者一个描述地址的对象。

    复制代码
    // 字符串
    router.push(&#39;home&#39;)

    // 对象
    this.$router.push(&#123;path: &#39;/login?url=&#39; + this.$route.path&#125;);

    // 命名的路由
    router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)

    // 带查询参数，变成/backend/order?selected=2
    this.$router.push(&#123;path: &#39;/backend/order&#39;, query: &#123;selected: &quot;2&quot;&#125;&#125;);

    // 设置查询参数
    this.$http.post(&#39;v1/user/select-stage&#39;, &#123;stage: stage&#125;)
    .then((&#123;data: &#123;code, content&#125;&#125;) =&gt; &#123;
        if (code === 0) &#123;
            // 对象
            this.$router.push(&#123;path: &#39;/home&#39;&#125;);
    &#125;else if(code === 10)&#123;
    // 带查询参数，变成/login?stage=stage
    this.$router.push(&#123;path: &#39;/login&#39;, query:&#123;stage: stage&#125;&#125;);
    &#125;
    &#125;);

    // 设计查询参数对象
    let queryData = &#123;&#125;;
    if (this.$route.query.stage) &#123;
        queryData.stage = this.$route.query.stage;
    &#125;
    if (this.$route.query.url) &#123;
        queryData.url = this.$route.query.url;
    &#125;
    this.$router.push(&#123;path: &#39;/my/profile&#39;, query: queryData&#125;);

    二，获取参数的两种常用方法：params 和 query

    （1）由于动态路由也是传递 params 的，所以在 this.$router.push()
    方法中 path 不能和 params 一起使用，否则 params 将无效。需要用 name 来指定页面。

    及通过路由配置的 name 属性访问
    this.$router.push(&#123;name:&quot;menuLink&quot;,params:&#123;alert:&quot;页面跳转成功&quot;&#125;&#125;)
    （2）在目标页面通过this.$route.params 获取参数：

    &lt;p&gt;提示：&#123;&#123;this.$route.params.alert&#125;&#125;&lt;/p&gt;
    （3）在目标页面通过this.$route.query 获取参数

    //传值
    this.$router.push(&#123;path:&quot;/menLink&quot;,query:&#123;alert:&quot;页面跳转成功&quot;&#125;&#125;)

    //用 query 获取值

    &lt;p&gt;提示：&#123;&#123;this.$route.query.alert&#125;&#125;&lt;/p&gt;

    两种方式的区别是 query 传参的参数会带在 url 后边展示在地址栏，
    params 传参的参数不会展示到地址栏。
    需要注意的是接收参数的时候是 route 而不是 router。两种方式一一对应，名字不能混用
</code></pre>
<h2 id="vue-router-实现路由懒加载（-动态加载路由-）"><a href="#vue-router-实现路由懒加载（-动态加载路由-）" class="headerlink" title="vue-router 实现路由懒加载（ 动态加载路由 ）"></a>vue-router 实现路由懒加载（ 动态加载路由 ）</h2><pre><code>    1. vue异步组件技术

    vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。

    但是，这种情况下一个组件生成一个js文件。

    举例如下：

    &#123;path:&#39;/promisedemo&#39;,name:&#39;PromiseDemo&#39;,
    component:resolve=&gt;require([&#39;../components/PromiseDemo&#39;],resolve)&#125;

    ts文件下需要设置

    2. es提案的import()

    推荐使用这种方式(需要webpack &gt; 2.4)

    webpack官方文档：webpack中使用import()

    vue官方文档：路由懒加载(使用import())

    vue-router配置路由，代码如下：

    // 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。

    const ImportFuncDemo1 = () =&gt; import(&#39;../components/ImportFuncDemo1&#39;)

    const ImportFuncDemo2 = () =&gt; import(&#39;../components/ImportFuncDemo2&#39;)

    // 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。

    // const ImportFuncDemo = () =&gt; import(/* webpackChunkName:
    &#39;ImportFuncDemo&#39; */ &#39;../components/ImportFuncDemo&#39;)

    // const ImportFuncDemo2 = () =&gt; import(/* webpackChunkName:
     &#39;ImportFuncDemo&#39; */ &#39;../components/ImportFuncDemo2&#39;)

    export default new Router(&#123;

    routes: [

    &#123; path: &#39;/importfuncdemo1&#39;, name: &#39;ImportFuncDemo1&#39;, component: ImportFuncDemo1 &#125;,

    &#123; path: &#39;/importfuncdemo2&#39;, name: &#39;ImportFuncDemo2&#39;, component: ImportFuncDemo2 &#125; ]

    &#125;)

    3、webpack提供的require.ensure()

    vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。

    这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。

    举例如下：

    &#123;path:&#39;/promisedemo&#39;,name:&#39;PromiseDemo&#39;,
    component:resolve=&gt;require.ensure([],()=&gt;resolve(require(&#39;../components/
          PromiseDemo&#39;)),&#39;demo&#39;)&#125;,&#123;path:&#39;/hello&#39;,name:&#39;Hello&#39;,
          // component: Hellocomponent:resolve=&gt;require.ensure
          ([],()=&gt;resolve (require(&#39;../components/Hello&#39;)),&#39;demo&#39;)
</code></pre>
<h2 id="拓展-SEO"><a href="#拓展-SEO" class="headerlink" title="拓展 SEO"></a>拓展 SEO</h2><pre><code>    SEO是指通过采用易于搜索引擎索引的合理手段，使网站各项基本要素适合
    搜索引擎检索原则并且对用户更友好（Search Engine Friendly），
    从而更容易被搜索引擎收录及优先排序从属于SEM（搜索引擎营销）。SEO的中文意思是搜索引擎优化。
    通俗理解是：通过总结搜索引擎的排名规律，对网站进行合理优化，使你的网站在百度和Google的排名提高，
    让搜索引擎给你带来客户。深刻理解是：通过SEO这样一套基于搜索引擎的营销思路，
    为网站提供生态式的自我营销解决方案，让网站在行业内占据领先地位，从而获得品牌收益。
    搜索引擎根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，
    为用户提供检索服务，将用户检索相关的信息展示给用户的系统。学习搜索引擎优化SEO，
    必须先了解什么是搜索引擎以及搜索引擎原理。搜索引擎包括全文索引、目录索引、元搜索引擎、
    垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Max</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/06/15/Vue/">http://example.com/2021/06/15/Vue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">犬夜叉的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a></div><div class="post_share"><div class="social-share" data-image="/img/back2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/06/15/React/"><img class="prev-cover" src="/img/tx.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Max</div><div class="author-info__description">心</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">VUE 的底层原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC"><span class="toc-number">2.</span> <span class="toc-text">MVC:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%EF%BC%9A%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%80%9D%E6%83%B3%EF%BC%8Cvue-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%9D%E6%83%B3%E7%AC%A6%E5%90%88-mvvm-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">MVVM：模式，思想，vue 框架的思想符合 mvvm 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-js-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">vue.js 优点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%EF%BC%9A%E4%BB%A5-v-%E5%BC%80%E5%A4%B4%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E6%93%8D%E4%BD%9C-DOM"><span class="toc-number">5.</span> <span class="toc-text">指令：以 v-开头的特殊属性，主要用来操作 DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">函数和计算属性的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD%E7%9A%84%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">vue 中的监听属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%8C%82%E5%9C%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">vue 挂在元素的方法和调用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%9Avue-%E5%AE%9E%E4%BE%8B%E4%BB%8E%E5%88%9B%E5%BB%BA%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%88%B0%E9%94%80%E6%AF%81%E4%BC%B4%E9%9A%8F%E7%9D%80%E4%B8%80%E4%BA%9B%E4%BA%8B%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9B%E4%BA%8B%E4%BB%B6%E5%8F%AB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%8C%E4%B9%9F%E5%8F%AB%E5%81%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E5%85%AB%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">9.</span> <span class="toc-text">生命周期钩子：vue 实例从创建，运行到销毁伴随着一些事件，这些事件叫生命周期钩子，也叫做生命周期函数八个生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90"><span class="toc-number">10.</span> <span class="toc-text">vue-router 有哪几种导航钩子?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">自定义指令：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">12.</span> <span class="toc-text">组件的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">13.</span> <span class="toc-text">双向数据绑定原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">14.</span> <span class="toc-text">组件通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">15.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">通过路由跳转的三种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">路由的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E8%B7%AF%E7%94%B1%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%80%BC"><span class="toc-number">18.</span> <span class="toc-text">vue-router 路由怎么获取传过来的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#route%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">$route和$router 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-this-router-push-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC%E5%92%8C%E8%8E%B7%E5%8F%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">20.</span> <span class="toc-text">vue 中 this.$router.push()路由传值和获取的两种常见方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%B7%AF%E7%94%B1-%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">vue-router 实现路由懒加载（ 动态加载路由 ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-SEO"><span class="toc-number">22.</span> <span class="toc-text">拓展 SEO</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/15/React/" title="React"><img src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React"/></a><div class="content"><a class="title" href="/2021/06/15/React/" title="React">React</a><time datetime="2021-06-14T16:00:00.000Z" title="发表于 2021-06-15 00:00:00">2021-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/15/Vue/" title="Vue"><img src="/img/back2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue"/></a><div class="content"><a class="title" href="/2021/06/15/Vue/" title="Vue">Vue</a><time datetime="2021-06-14T16:00:00.000Z" title="发表于 2021-06-15 00:00:00">2021-06-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Max</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>